# Building software that makes a difference
```
    - The problems that BDD solves
    - General principles of BDD
    - Acitivies and outcomes in BDD
    - Pros and cons of BDD
```
## BDD from 50,000 feet
  ![SDLC](/resoucrce/TraditionalSDLC.png)
  ![BDD](/resoucrce/BDD.png)
## What problems are you trying to solve?
  ![FailedSW](/resoucrce/FailedSW.png)
  ![TDD](/resoucrce/TDD.png)
## Introducing the BDD
  ![BDD](/resoucrce/ActivitiesAndOutcomeBDD.png)
  ![Example](/resoucrce/ExamplesRole.png)
  ![Gherkin](/resoucrce/GherkinStructure.png)
  ![GherkinExample](/resoucrce/GherkinExample.png)
  ![ExecutableSpecification](/resoucrce/ExecutableSpecification.png)
  ![LowLevel](/resoucrce/LowLevelExecutableSpecification.png)
  ![HighLevelAndLowLevel](/resoucrce/HighLevelAndLowLevelExecutableSpecification.png)
  ![GenerateLivingDoc](/resoucrce/GenerateLivingDoc.png)
  ![WellLivingDoc](/resoucrce/WellOrganizedLivingDoc.png)
## Benefits of BDD
## Disadvantages and potential challenges of BDD




# BDD-the whirlwind tour
```
  - An end-to-end walkthrough of BDD practices in action
  - Discovering features and describing them through stories and examples
  - Using executable specifications to specify features in detail
  - Using low-level BDD to implement features
  - Using BDD test results as living documentation
  - Using living documentation to support ongoing maintenance
```
## Introducing the train timetable application
## Determining the value proposition of the application
## Requirements analysis: Discovering and Understanding features
### Describing features
### Breaking features down into stories
### Illustrating features with examples
## Implementation: Building and delivering features
### Going from examples to acceptance criteria
### Setting up Maven and Git
### Excutable specifications: Automating acceptance criteria
### Automation tests: Implementing the acceptance criteria
### Tests as living documentation
## Maintenance